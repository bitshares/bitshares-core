/*
 * Copyright (c) 2015 Cryptonomex, Inc., and contributors.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 *
 * 1. Any modified source or binaries are used only with the BitShares network.
 *
 * 2. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 *
 * 3. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
#pragma once

#define GRAPHENE_NET_PROTOCOL_VERSION                        106

/**
 * Define this to enable debugging code in the p2p network interface.
 * This is code that would never be executed in normal operation, but is
 * used for automated testing (creating artificial net splits,
 * tracking where messages came from and when)
 */
#define ENABLE_P2P_DEBUGGING_API                             1

/**
 * 2MiB
 */
#define MAX_MESSAGE_SIZE                                     1024*1024*2
#define GRAPHENE_NET_DEFAULT_PEER_CONNECTION_RETRY_TIME      30 // seconds

/**
 * AFter trying all peers, how long to wait before we check to
 * see if there are peers we can try again.
 */
#define GRAPHENE_PEER_DATABASE_RETRY_DELAY                   15 // seconds

#define GRAPHENE_NET_PEER_HANDSHAKE_INACTIVITY_TIMEOUT       5

#define GRAPHENE_NET_PEER_DISCONNECT_TIMEOUT                 20

#define GRAPHENE_NET_TEST_SEED_IP                            "104.236.44.210" // autogenerated
#define GRAPHENE_NET_TEST_P2P_PORT                           1700
#define GRAPHENE_NET_DEFAULT_P2P_PORT                        1776
#define GRAPHENE_NET_DEFAULT_DESIRED_CONNECTIONS             20
#define GRAPHENE_NET_DEFAULT_MAX_CONNECTIONS                 200

#define GRAPHENE_NET_MAXIMUM_QUEUED_MESSAGES_IN_BYTES        (1024 * 1024)

/**
 * When we receive a message from the network, we advertise it to
 * our peers and save a copy in a cache were we will find it if
 * a peer requests it.  We expire out old items out of the cache
 * after this number of blocks go by.
 * 
 * Recently lowered from 30 to match the default expiration time
 * the web wallet imposes on transactions.
 */
#define GRAPHENE_NET_MESSAGE_CACHE_DURATION_IN_BLOCKS        5

/**
 * We prevent a peer from offering us a list of blocks which, if we fetched them
 * all, would result in a blockchain that extended into the future.
 * This parameter gives us some wiggle room, allowing a peer to give us blocks
 * that would put our blockchain up to an hour in the future, just in case
 * our clock is a bit off.
 */
#define GRAPHENE_NET_FUTURE_SYNC_BLOCKS_GRACE_PERIOD_SEC     (60 * 60)

#define GRAPHENE_NET_MAX_INVENTORY_SIZE_IN_MINUTES           2

#define GRAPHENE_NET_MAX_BLOCKS_PER_PEER_DURING_SYNCING      200

/**
 * During normal operation, how many items will be fetched from each
 * peer at a time.  This will only come into play when the network
 * is being flooded -- typically transactions will be fetched as soon
 * as we find out about them, so only one item will be requested
 * at a time.
 * 
 * No tests have been done to find the optimal value for this
 * parameter, so consider increasing or decreasing it if performance
 * during flooding is lacking.
 */
#define GRAPHENE_NET_MAX_ITEMS_PER_PEER_DURING_NORMAL_OPERATION  1 

/**
 * Instead of fetching all item IDs from a peer, then fetching all blocks
 * from a peer, we will interleave them.  Fetch at least this many block IDs,
 * then switch into block-fetching mode until the number of blocks we know about
 * but haven't yet fetched drops below this
 */
#define GRAPHENE_NET_MIN_BLOCK_IDS_TO_PREFETCH               10000

#define GRAPHENE_NET_MAX_TRX_PER_SECOND                      1000
